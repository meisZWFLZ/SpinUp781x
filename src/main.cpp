// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ExpansionPiston      digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// DigitalOutF          digital_out   F
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult1            motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult             motor_group   13, 14
// CatapultLimitSwitch  limit         G
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult             motor_group   13, 14
// LimitSwitchG         limit         G
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// Catapult             motor_group   13, 14
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller
// PTOLeft              motor         2
// PTORight             motor         3
// PTOPiston            digital_out   H
// LeftDriveA           motor         4
// LeftDriveB           motor         5
// RightDriveA          motor         6
// RightDriveB          motor         11
// FlyWheel             motor_group   8, 9
// HoriEncoder          encoder       A, B
// VertEncoder          encoder       C, D
// Inertial10           inertial      1
// VisionSensor         vision        12
// ---- END VEXCODE CONFIGURED DEVICES ----
#include "auton/elements.h"
#include "conversions.h"
#include "odom/tracking.h"
#include "pid_controller.h"
#include "position.h"
#include "vex.h"
#include <atomic>
#include <auton/action.h>
#include <cmath>
#include <iostream>
#include <thread>
#include <vector>

// using namespace std::chrono_literals;

// #ifndef ODOMTRACKING_CPP
// #include "odom/tracking.cpp"
// #endif

/*
- normal drivetrain?
- tank drive control scheme
- automatic shooting :(
- distance in inches
*/

const Position GOAL_POS = {18, 18, 0};

// enum Button {
//   CANCEL_SHOOTING,
//   EXPANSION,
//   SAFTEY_SWITCH /*enables and disables saftey mechanisms*/,
//   SHOOT,
//   ROLLER,
//   INTAKE,
//   UNSTUCK_INTAKE,
//   PTO_SWITCH,
//   FLY_WHEEL_TOGGLE
// };

// controller::button getControllerButton(Button button) {
//   controller::button ControllerButtons[] = {
//       Controller1.ButtonA,  Controller1.ButtonB,    Controller1.ButtonX,
//       Controller1.ButtonY,  Controller1.ButtonDown, Controller1.ButtonR1,
//       Controller1.ButtonR2, Controller1.ButtonLeft, Controller1.ButtonUp};
//   return ControllerButtons[button];
// }

enum Axis { LEFT_DRIVE, RIGHT_DRIVE };

controller::axis getControllerAxis(Axis axis) {
  controller::axis ControllerAxises[] = {Controller1.Axis3, Controller1.Axis2};
  return ControllerAxises[axis];
}

// motor_group PTOGroup = motor_group(PTOLeft, PTORight);

// // const std::chrono::duration<long long, milli> LENGTH_OF_GAME = 12000ms;
// const int LENGTH_OF_GAME = 20000;
// // const std::chrono::duration<long long, milli> LENGTH_OF_ENGAME = 10000ms;
// const int LENGTH_OF_ENGAME = 10000;

// // const std::chrono::steady_clock::time_point TIME_OF_ENGAME =
// // chrono::steady_clock::now() + LENGTH_OF_GAME - LENGTH_OF_ENGAME;
// const int TIME_OF_ENGAME =
//     /* chrono::steady_clock::now() + */ LENGTH_OF_GAME - LENGTH_OF_ENGAME;

// // const std::chrono::duration<long long, milli> DISC_LOAD_DELAY = 500ms;
// // //should be time piston takes to complete full cycle
// const int DISC_LOAD_DELAY =
//     200; // should be time piston takes to complete full cycle

// static const int DISC_LOADER_DISTANCE = 720;

// static bool shooting = false; // disables drivetrain whilst aiming/shooting
// static int shots = 0; // tap shoot button to add more discs after original
// press static bool cancelShooting = false;

// static atomic<bool> shootingYawed;   // wait until yawed to shoot
// static atomic<bool> shootingPitched; // wait until pitched to shoot

// static bool PTOSwitching = false; // Disable PTO motors and drivetrain

static bool flyWheelSpin = false;

// static bool expanded = false;
// static bool saftey = false; // true -> disables saftey mechanisms

static OdomTracking *tracker;

// bool buttonPressed(Button button) {
//   return getControllerButton(button).pressing();
// }

int axisPosition(Axis axis) { return getControllerAxis(axis).position(); }

// void PTOIntake() {
//   if (PTOState)
//     return;
//   Brain.Screen.print("intake");
//   PTOPiston.set(false);
//   // freeze drivetrain and pto motors
//   PTOState = true;
//   PTOSwitching = false;
// }

// void PTODrivetrain() {
//   if (!PTOState)
//     return;
//   Brain.Screen.print("drive");
//   PTOPiston.set(true);
//   // freeze drivetrain and pto motors
//   PTOState = false;
//   PTOSwitching = false;
// }

// void endgameExpansion() {
//   // expansion stuff
// }

// void loadDisc() {
//   PTOGroup.setVelocity(100, pct);
//   PTOGroup.spinFor(reverse, DISC_LOADER_DISTANCE, degrees);
// }

// Position getPosition() { return {}; } // gets robot position

// void turn(double newHeading) {
//   Brain.Screen.setCursor(2, 1);
//   Brain.Screen.clearLine();
//   Brain.Screen.print(newHeading);
//   double hDiff = getPosition().heading - newHeading;
//   spinLeftDrive(hDiff ? fwd : reverse, 10, pct);
//   spinRightDrive(hDiff ? reverse : fwd, 10, pct);
//   while (abs(getPosition().heading - newHeading) > 0.1)
//     wait(10, msec);
// };

// void aimTurret(int distance /*inches*/) { wait(0, msec); }

// void expansionButtonSubscriber() {
//   // prevents expansion untill endgame
//   if (saftey || 432423 > TIME_OF_ENGAME)
//     endgameExpansion();
// }

// void cancelShootingButtonSubscriber() { cancelShooting = true; }

// void safteySwitchSubscriber() { saftey = !saftey; }
// void shoot() {
//   // aiming
//   Position pos = getPosition();
//   if (!cancelShooting) {
//     double xDiff = GOAL_POS.x - pos.x;
//     double yDiff = GOAL_POS.y - pos.y;
//     turn(atan(yDiff / xDiff) + (xDiff > 0 ? 180 : !(yDiff > 0) ? 360 : 0));
//   }
//   if (!cancelShooting)
//     aimTurret(Position::distance(pos, GOAL_POS));

//   // shooting
//   for (int i = 0; i < 3 && !cancelShooting && i < shots; i++) {
//     loadDisc();

//     // wait for delay to repeat
//     this_thread::sleep_for(DISC_LOAD_DELAY);
//   }
//   shots = 0;
//   cancelShooting = false;
//   shooting = false;
// }

// void shootButtonSubscriber() {
//   Brain.Screen.print("pressed");
//   shots = shots + 1;
//   if (shooting)
//     return;
//   shooting = true;

//   thread Thread;
//   (thread(shoot));
// }

// void PTOSwitchSubscriber() {
//   PTOSwitching = true;
//   if (PTOState)
//     PTODrivetrain();
//   else
//     PTOIntake();
// }

// void intakeButtonSubscriber() {
//   PTOIntake();
//   PTOGroup.spin(fwd, 100, pct);
// }

// void intakeReleasedSubscriber() { PTOGroup.stop(); }

// void unstuckIntakeButtonSubscriber() {
//   PTOIntake();
//   PTOGroup.spin(reverse, 100, pct);
// }

// void unstuckIntakeReleasedSubscriber() { PTOGroup.stop(); }

// void subscribeButtonListener(Button button, void (*callback)()) {
//   getControllerButton(button).pressed(callback);
// }

// void subscribeReleasedListener(Button button, void (*callback)()) {
//   getControllerButton(button).released(callback);
// }

// void subscribeAxisListener(Axis axis, void (*callback)()) {
//   getControllerAxis(axis).changed(callback);
// }
enum PTO { DRIVE, INTAKE };

static atomic<bool> PTOState = {INTAKE}; // false = drivetrain, true = intake

// enum class TEAM : bool { RED, BLUE } TEAM;
// enum TEAM team;
enum class ROLLER : int { RED, BLUE, IN_BETWEEN } ROLLER;

static const bool operator==(const enum Robot::TEAM team1,
                             const enum ROLLER roller1) {
  return (int)team1 == (int)roller1;
};
static const bool operator==(const enum ROLLER roller1,
                             const enum Robot::TEAM team1) {
  return (int)team1 == (int)roller1;
};

void flyWheelButtonSubscriber() {
  flyWheelSpin = !flyWheelSpin;
  if (flyWheelSpin)
    FlyWheel.spin(fwd, 10, volt);
  else
    FlyWheel.stop();
}

void spinLeftDrive(directionType dir, double velocity, percentUnits units) {
  std::vector<motor> motors;
  if (PTOState == PTO::INTAKE)
    motors = {LeftDriveA, LeftDriveB}; // intake
  else
    motors = {LeftDriveA, LeftDriveB, PTOLeft}; // drivetrain
  for (auto i = motors.begin(); i != motors.end(); ++i)
    i->spin(dir, velocity, units);
};

void spinRightDrive(directionType dir, double velocity, percentUnits units) {
  std::vector<motor> motors;
  if (PTOState == PTO::INTAKE)
    motors = {RightDriveA, RightDriveB}; // intake
  else
    motors = {RightDriveA, RightDriveB, PTORight}; // drivetrain
  for (auto i = motors.begin(); i != motors.end(); ++i)
    i->spin(dir, velocity, units);
}

void leftDriveSubscriber() {
  spinLeftDrive(fwd, pow((float)axisPosition(LEFT_DRIVE) / 100, 5) * 100, pct);
}

void rightDriveSubscriber() {
  spinRightDrive(fwd, pow((float)axisPosition(RIGHT_DRIVE) / 100, 5) * 100,
                 pct);
}

struct RollerArea {
public:
  int red;
  int blue;
  void update();
  RollerArea();
};

atomic<bool> spinningRoller = {false};
RollerArea rollArea = {};

RollerArea::RollerArea() : red(0), blue(0) {}
void RollerArea::update() {
  VisionSensor.takeSnapshot(VisionSensor__RED_ROLLER);
  vision::object redObj = VisionSensor.largestObject;
  red = redObj.width * redObj.height;
  VisionSensor.takeSnapshot(VisionSensor__BLUE_ROLLER);
  vision::object blueObj = VisionSensor.largestObject;
  blue = blueObj.width * blueObj.height;
  printf("updating\n");
};

enum ROLLER whatIsRoller() {
  rollArea.update();
  if (rollArea.red > 1000 && rollArea.red > rollArea.blue * 5)
    return ROLLER::RED;
  if (rollArea.blue > 1000 && rollArea.blue > rollArea.red * 5)
    return ROLLER::BLUE;
  return ROLLER::IN_BETWEEN;
};

void visionAidedRoller() {
  if (whatIsRoller() == Robot::team)
    return;
  Robot::Actions::pto(Robot::PTO_STATE::INTAKE);
  spinningRoller = true;
  PTOLeft.spin(fwd, 25, pct);
  PTORight.spin(fwd, 25, pct);
  while (!(whatIsRoller() == Robot::team)) {
    printf("vision roller\n");
    wait(20, msec);
  }
  spinningRoller = false;
  PTOLeft.stop();
  PTORight.stop();
};

// bool readyToShoot = true;

void shootListener() { Robot::Actions::shoot((Robot::GOAL)(int)Robot::team); }

struct NEW_PRESS {
  static atomic<bool> R1;
  static atomic<bool> L1;
  static atomic<bool> R2;
  static atomic<bool> L2;
};
atomic<bool> NEW_PRESS::R1 = {false};
atomic<bool> NEW_PRESS::L1 = {false};
atomic<bool> NEW_PRESS::R2 = {false};
atomic<bool> NEW_PRESS::L2 = {false};

atomic<bool> PTOWasSwitched = {false};

void shiftKeyStuff() {
  while (1) {
    if (NEW_PRESS::R1)
      if (NEW_PRESS::L1) {
        // pto switch
        Robot::Actions::pto((Robot::PTO_STATE)(!((bool)Robot::PTOState)));
        PTOWasSwitched = true;
      } else {
        Robot::Actions::intake();
        printf("intake in\n");
      }
    else if (NEW_PRESS::L1) {
      Robot::Actions::shoot(Robot::GOAL::MY_TEAM);
      // printf("shoot\n");
      // shootListener();
    }

    // if (!spinningRoller)
    //   rollArea.update();
    // printf("red: %d, blue: %d\n", rollArea.red, rollArea.blue);
    // if ((rollArea.red + rollArea.blue) > 30000)
    //   visionAidedRoller();
    wait(100, msec);
  }
}

void controllerDisplay(OdomTracking);

void motorSetup() {
  // FlyWheel.setStopping(coast);
  ExpansionPiston.set(false);

  Catapult1.setStopping(hold);

  LeftDriveA.setStopping(coast);
  LeftDriveB.setStopping(coast);
  RightDriveA.setStopping(coast);
  RightDriveB.setStopping(coast);

  PTOPiston.set(false);
}

// void tracking() {
//   OdomTracking tracker1 = {{0, 0, 0}};
//   tracker = &tracker1;
// }

const float pidLimit = 50; // pct

float leftAdjustment = 0;
float rightAdjustment = 0;

void spinLeftPID(const float velocityPercent) {
  leftAdjustment += velocityPercent;
};

void spinRightPID(const float velocityPercent) {
  rightAdjustment += velocityPercent;
};

void spinBothPID(const float velocityPercent) {
  spinRightPID(velocityPercent);
  spinLeftPID(velocityPercent);
  // if (abs(velocityPercent) < pidLimit) {
  //   spinRightDrive(fwd, velocityPercent, pct);
  //   spinLeftDrive(fwd, velocityPercent, pct);
  // } else {
  //   printf("both at limit: %f\n", velocityPercent);
  //   spinRightDrive(fwd, velocityPercent > 0 ? pidLimit : -pidLimit, pct);
  //   spinLeftDrive(fwd, velocityPercent > 0 ? pidLimit : -pidLimit, pct);
  // }
};

void spinPID() {
  if (abs(leftAdjustment) < pidLimit)
    spinLeftDrive(fwd, leftAdjustment, pct);
  else {
    printf("left at limit: %f\n", leftAdjustment);
    spinLeftDrive(fwd, leftAdjustment > 0 ? pidLimit : -pidLimit, pct);
  }
  if (abs(rightAdjustment) < pidLimit)
    spinRightDrive(fwd, rightAdjustment, pct);
  else {
    printf("right at limit: %f\n", rightAdjustment);
    spinRightDrive(fwd, rightAdjustment > 0 ? pidLimit : -pidLimit, pct);
  }
  leftAdjustment = 0;
  rightAdjustment = 0;
};

float getLeftPID() {
  return (LeftDriveA.position(degrees) + LeftDriveB.position(degrees)) / 2;
};

float getRightPID() {
  return (RightDriveA.position(degrees) + RightDriveB.position(degrees)) / 2;
};

float getBothPID() { return (getRightPID() + getLeftPID()) / 2; };

void pid() {
  spinLeftPID(10);
  const float kP = 0.5;
  float error = 0;
  float proportional = 0;
  while (1) {
    error = getLeftPID() - getRightPID();
    proportional = error * kP;
    spinRightPID(10 + proportional);
    printf("error: %f, pro: %f\n", error, proportional);
    wait(20, msec);
  }
}

static constexpr float pi2 = 2 * M_PI;
float headingDifference(float a, float b) {
  const float diff = a - b;
  return (diff +
          pi2 * (diff > 0 ? (diff > M_PI ? -1 : 0) : diff < -M_PI ? 1 : 0));
}
PIDController::Callback *stopPID;
PIDController::Callback *turnPID;
// float target = 0;

class AutonSelection {
public:
  static std::vector<std::function<void(void)>> autonArr;
  static int autonPos;
  static void print() {
    Brain.Screen.clearScreen();
    Brain.Screen.setFont(monoXXL);
    Brain.Screen.setFillColor(transparent);
    Brain.Screen.setCursor(1, 1);
    Brain.Screen.print(autonPos);
    Brain.Screen.setFillColor(Robot::TEAM::RED == Robot::team ? red : blue);
    Brain.Screen.drawRectangle(240, 0, 480, 240);
  }
  static void listener() {
    if (Brain.Screen.xPosition() < 240) {
      // auton
      autonPos = (autonPos + 1) % autonArr.size();
    } else {
      // team
      Robot::team = Robot::TEAM::RED == Robot::team ? Robot::TEAM::BLUE
                                                    : Robot::TEAM::RED;
    }
    print();
  }
  static const void
  start(const std::vector<std::function<void(void)>> autonArr1) {
    autonArr = autonArr1;
    Brain.Screen.setFont(monoXXL);
    Brain.Screen.pressed(AutonSelection::listener);
    print();
  };
  static void run() {
    Brain.Screen.setFont(monoL);
    Brain.Screen.setFillColor(transparent);
    autonArr[autonPos]();
  };
};
std::vector<std::function<void(void)>> AutonSelection::autonArr = {};
int AutonSelection::autonPos = 0;

// void autonSelection(const std::vector<std::function<void(void)>> autonArr1) {
//   static int autoPos = 0;
//   static const std::vector<std::function<void(void)>> autonArr = autonArr1;
// }
competition Competition;
void autonomous() {
  Robot::Drivetrain::left(10);
  Robot::Drivetrain::right(10);
  wait(250, msec);
  AutonSelection::run();
  // Robot::Actions::outtake();
  // Robot::Drivetrain::left(-10);
  // Robot::Drivetrain::right(-10);
  wait(250, msec);
  // Robot::Actions::stopIntake();
  Robot::Drivetrain::left(0);
  Robot::Drivetrain::right(0);
  // Robot::Drivetrain::left(30);
  // Robot::Drivetrain::right(30);
  // wait(750, msec);
  // // AutonSelection::run();
  // Robot::Actions::outtake();
  // Robot::Drivetrain::left(-15);
  // Robot::Drivetrain::right(-15);
  // wait(750, msec);
  // Robot::Actions::stopIntake();
  // Robot::Drivetrain::left(0);
  // Robot::Drivetrain::right(0);
};
void driverControl() {
  thread([] { controllerDisplay({{}}); });
  // drive code
  Controller1.Axis2.changed(&rightDriveSubscriber);
  Controller1.Axis3.changed(&leftDriveSubscriber);

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    START CATA TEST
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Controller1.ButtonUp.pressed([]() {
    Catapult1.spin(fwd, 100, pct);
    while (Controller1.ButtonUp.pressing()) {
      wait(10, msec);
    }
    Catapult1.stop();
  });
  Controller1.ButtonDown.pressed([]() {
    Catapult1.spin(reverse, 100, pct);
    while (Controller1.ButtonDown.pressing()) {
      wait(10, msec);
    }
    Catapult1.stop();
  });

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    END CATA TEST
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // R1 -> intake in
  // R2 -> intake out
  // L1 -> shoot
  // R1 L1 -> pto switch
  // R2 L2 -> flywheel toggle
  // L2 -> roller
  // a b -> expansion

  // shoot pressed
  Controller1.ButtonL1.pressed([]() {
    NEW_PRESS::L1 = true;
    wait(100, msec);
    NEW_PRESS::L1 = false;
  });
  // intake pressed
  Controller1.ButtonR1.pressed([]() {
    NEW_PRESS::R1 = true;
    wait(100, msec);
    NEW_PRESS::R1 = false;
  });
  // intake released
  Controller1.ButtonR1.released([]() {
    if (!PTOWasSwitched) {
      PTOLeft.stop();
      PTORight.stop();
      printf("intake stopped\n");
    } else
      PTOWasSwitched = false;
  });
  // outtake pressed
  Controller1.ButtonR2.pressed([]() {
    // NEW_PRESS::R2 = true;
    // wait(200, msec);
    // NEW_PRESS::R2 = false;
    Robot::Actions::pto(Robot::PTO_STATE::INTAKE);
    PTOLeft.spin(reverse, 12, volt);
    PTORight.spin(reverse, 12, volt);
    printf("intake in\n");
  });
  // outtake released
  Controller1.ButtonR2.released([]() {
    PTOLeft.stop();
    PTORight.stop();
    printf("intake stopped\n");
  });

  Controller1.ButtonL2
      .pressed(
          &visionAidedRoller /* []() {
  NEW_PRESS::L2 = true;
  wait(200, msec);
  NEW_PRESS::L2 = false;
  } */);

  // flywheel
  // Controller1.ButtonUp.pressed(&flyWheelButtonSubscriber);
  // temp testing flywheel
  // Brain.Screen.pressed(&flyWheelButtonSubscriber);

  // start shiftKeyNonsense
  Controller1.ButtonA.pressed([] {
    if (Controller1.ButtonB.pressing())
      Robot::Actions::expand();
  });
  Controller1.ButtonB.pressed([] {
    if (Controller1.ButtonA.pressing())
      Robot::Actions::expand();
  });

  thread Thread;
  (thread(shiftKeyStuff));

  // Controller1.ButtonA.pressed([]() {
  //   while (abs(tracker1->getRobotPosition().heading - M_PI) > 0.01)
  //     printf("%f\n", tracker1->getRobotPosition().heading);
  // });

  // ANYTHING AFTER THIS FUNCTION WILL NOT BE EXECUTED
  // controllerDisplay({{}});
}
void preAuton() {
  using namespace auton;
  AutonSelection::start({[] {
                           //  Path({new Roller()}).execute();
                           //  tracker->reset(Robot::team == Robot::TEAM::RED
                           //                     ? elements::ROLLER::BLUE_LEFT
                           //                     : elements::ROLLER::RED_LEFT);
                            PTOLeft.setPosition(0, deg);
                            PTORight.setPosition(0, deg);
                            PTOLeft.spin(fwd, -100, pct);
                            PTORight.spin(fwd, -100, pct);
                           //  int lastPos
                            while ((PTOLeft.position(turns) +
                            PTORight.position(turns)) / 2 < 2)
                              wait(10, msec);
                            PTOLeft.stop();
                            PTORight.stop();
                         },
                         [] {
                           //  tracker->reset({60, 60, 0});
                         }});
}
int main() {
  vexcodeInit();
  // return 1;
  motorSetup();

  Robot::team = Robot::TEAM::BLUE;

  OdomTracking tracker1 = {{}};
  tracker = &tracker1;

  tracker->reset({35, 135, 0});
  Inertial10.calibrate(2);
  // wait until inertial finsished calibrating
  while (Inertial10.isCalibrating())
    wait(20, msec);

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    START COMPETITION
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // Competition.autonomous(autonomous);
  // Competition.drivercontrol(driverControl);
  preAuton();
  driverControl();
  while (1) {
    wait(100, msec);
  }
  return 1;

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    END COMPETITION
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // drivetrain code
  Controller1.Axis2.changed(&rightDriveSubscriber);
  Controller1.Axis3.changed(&leftDriveSubscriber);

  // odometry

  // team

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    START CATA TEST
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // Catapult1.setVelocity(100, percent);

  Controller1.ButtonUp.pressed([]() {
    Catapult1.spin(fwd, 100, pct);
    while (Controller1.ButtonUp.pressing()) {
      wait(10, msec);
    }
    Catapult1.stop();
  });
  Controller1.ButtonDown.pressed([]() {
    Catapult1.spin(reverse, 100, pct);
    while (Controller1.ButtonDown.pressing()) {
      wait(10, msec);
    }
    Catapult1.stop();
  });

  // return 1;

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    END CATA TEST
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    START AUTON TESTING
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // auto x = []() {
  //   using namespace auton;
  //   Path({
  //            new GoTo(Robot::team == Robot::TEAM::BLUE
  //                         ? elements::ROLLER::BLUE_LEFT
  //                         : elements::ROLLER::RED_LEFT),
  //            //  new Roller(),
  //            new GoTo(Robot::team == Robot::TEAM::BLUE
  //                         ? elements::ROLLER::BLUE_RIGHT
  //                         : elements::ROLLER::RED_RIGHT),
  //            //  new Roller(),
  //            //  new GoTo(Robot::team == Robot::TEAM::BLUE
  //            //               ? elements::ROLLER::BLUE_LEFT
  //            //               : elements::ROLLER::RED_LEFT),
  //        })
  //       .execute();
  // };
  // tracker->reset(elements::ROLLER::LEFT);
  // Controller1.ButtonX.pressed([]() {
  //   []() {

  // });
  // (thread([]() {
  //   Position robotPos1;

  //   while (1) {
  //     Controller1.Screen.setCursor(0, 0);

  //     robotPos1 = tracker->getRobotPosition();
  //     Controller1.Screen.clearLine();
  //     Controller1.Screen.print("(");
  //     Controller1.Screen.print(robotPos1.x);
  //     Controller1.Screen.print(",");
  //     Controller1.Screen.print(robotPos1.y);
  //     Controller1.Screen.print(",");
  //     Controller1.Screen.print(robotPos1.heading);
  //     Controller1.Screen.print(")");
  //     Controller1.Screen.newLine();
  //     wait(20, msec);

  //     Brain.Screen.clearLine();
  //     Brain.Screen.print("(");
  //     Brain.Screen.print(robotPos1.x);
  //     Brain.Screen.print(",");
  //     Brain.Screen.print(robotPos1.y);
  //     Brain.Screen.print(",");
  //     Brain.Screen.print(robotPos1.heading);
  //     Brain.Screen.print(")");
  //     Brain.Screen.newLine();
  //     wait(20, msec);
  //   }
  // }));
  // Controller1.ButtonX.pressed([]() {
  //   auton::GoTo goTo = {{}};
  //   goTo.execute();
  // });

  // return 1;
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    END AUTON TESTING
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  if (0) {

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //    START PID TESTING
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // pid();
    // drive straight
    // spinLeftPID(10);
    // PIDController::Callback(
    //     0.5, 0, 0, 20, []() -> float { return getLeftPID() - getRightPID();
    // },
    //     [](float adjustment) { spinRightPID(10 + adjustment); })
    //     .pidLoop();

    // stop at distance
    PIDController::Callback stop = PIDController::Callback(
        1, 0, 0, 20,
        []() -> float {
          const float distance =
              Position::distance(tracker->getRobotPosition());
          printf(")distance:%f\n", distance);
          return distance;
        },
        [](float adjustment1) {
          const Position vector =
              Position::difference({0, 0, 0}, tracker->getRobotPosition());
          const float target1 = atan2(vector.x, vector.y);
          const float target = target1 < 0 ? target1 + pi2 : target1;
          const float heading1 =
              Conversions::Degrees::toRadians(Inertial10.heading(degrees));

          const float adjustment =
              pow(cos(headingDifference(target, heading1)), 5) * 30 *
              adjustment1 / (2 + abs(adjustment1));
          printf("=stop adjustment: %f\n", adjustment);
          spinBothPID(adjustment);
        });
    // .pidLoop();
    // turn

    PIDController::Callback turn = PIDController::Callback(
        1, 0.000, 0, 20,
        []() -> float {
          const Position vector =
              Position::difference({0, 0, 0}, tracker->getRobotPosition());
          // const float target1 = atan2(vector.x, vector.y);
          // const float target = target1 < 0 ? target1 + pi2 : target1;
          // const float conIn =
          //     ((((float)Controller1.Axis1.position()) / 100) + 1) * M_PI;
          // const Position vector = {cos(conIn), sin(conIn), 0};
          const float target1 = atan2(vector.x, vector.y);
          const float target = target1 < 0 ? target1 + pi2 : target1;

          const float heading1 =
              Conversions::Degrees::toRadians(Inertial10.heading(degrees));
          // const float heading = heading1 > M_PI ? heading1 - pi2 :
          // heading1;
          const float headingDiff =
              headingDifference(target, heading1) /*  * 100 */;
          printf("{heading: %f\n+diff: %f\n@target: %f\n&input: %f\n", heading1,
                 headingDiff /*  / 100 */, target, 1);
          return headingDiff;
        },
        [](const float adjustment1) {
          const float adjustment = (30 * adjustment1 / (0.5 + abs(adjustment1)))
              // * (Position::distance(tracker->getRobotPosition()) /
              //  (0.5 +
              //  abs(Position::distance(tracker->getRobotPosition()))))
              ;
          printf("=turn adjustment: %f\n", adjustment);
          spinLeftPID(adjustment);
          spinRightPID(-adjustment);
        });
    stopPID = &stop;
    turnPID = &turn;
    Controller1.ButtonX.pressed([]() {
      // const Position vector =
      //     Position::difference({0, 0, 0}, tracker->getRobotPosition());
      // const float target1 = atan2(vector.x, vector.y);
      // target = target1 < 0 ? target1 + pi2 : target1;
      while (abs(Position::distance(tracker->getRobotPosition())) > 0.1) {
        if (Controller1.ButtonA.pressing())
          break;
        stopPID->pidSegment();
        turnPID->pidSegment();

        spinPID();
        wait(20, msec);
      }
      RightDriveA.stop();
      RightDriveB.stop();
      LeftDriveA.stop();
      LeftDriveB.stop();
    });

    // // pid but not
    // Controller1.ButtonX.pressed([]() {

    // });

    // position printing
    (thread([]() {
      Position robotPos1;

      while (1) {
        Controller1.Screen.setCursor(0, 0);

        robotPos1 = tracker->getRobotPosition();
        Controller1.Screen.clearLine();
        Controller1.Screen.print("(");
        Controller1.Screen.print(robotPos1.x);
        Controller1.Screen.print(",");
        Controller1.Screen.print(robotPos1.y);
        Controller1.Screen.print(",");
        Controller1.Screen.print(robotPos1.heading);
        Controller1.Screen.print(")");
        Controller1.Screen.newLine();
        wait(20, msec);

        Brain.Screen.clearLine();
        Brain.Screen.print("(");
        Brain.Screen.print(robotPos1.x);
        Brain.Screen.print(",");
        Brain.Screen.print(robotPos1.y);
        Brain.Screen.print(",");
        Brain.Screen.print(robotPos1.heading);
        Brain.Screen.print(")");
        Brain.Screen.newLine();
        wait(20, msec);
      }
    }));

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //    END PID TESTING
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  } else {

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //  START I/O INITIALIZATION
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // R1 -> intake in
    // R2 -> intake out
    // L1 -> shoot
    // R1 L1 -> pto switch
    // R2 L2 -> flywheel toggle
    // L2 -> roller

    // shoot pressed
    Controller1.ButtonL1.pressed([]() {
      NEW_PRESS::L1 = true;
      wait(100, msec);
      NEW_PRESS::L1 = false;
    });
    // intake pressed
    Controller1.ButtonR1.pressed([]() {
      NEW_PRESS::R1 = true;
      wait(100, msec);
      NEW_PRESS::R1 = false;
    });
    // intake released
    Controller1.ButtonR1.released([]() {
      if (!PTOWasSwitched) {
        PTOLeft.stop();
        PTORight.stop();
        printf("intake stopped\n");
      } else
        PTOWasSwitched = false;
    });
    // outtake pressed
    Controller1.ButtonR2.pressed([]() {
      // NEW_PRESS::R2 = true;
      // wait(200, msec);
      // NEW_PRESS::R2 = false;
      Robot::Actions::pto(Robot::PTO_STATE::INTAKE);
      PTOLeft.spin(reverse, 12, volt);
      PTORight.spin(reverse, 12, volt);
      printf("intake in\n");
    });
    // outtake released
    Controller1.ButtonR2.released([]() {
      PTOLeft.stop();
      PTORight.stop();
      printf("intake stopped\n");
    });

    Controller1.ButtonL2.pressed(
        &visionAidedRoller /* []() {
NEW_PRESS::L2 = true;
wait(200, msec);
NEW_PRESS::L2 = false;
} */);

    // flywheel
    // Controller1.ButtonUp.pressed(&flyWheelButtonSubscriber);
    // temp testing flywheel
    Brain.Screen.pressed(&flyWheelButtonSubscriber);

    // start shiftKeyNonsense
    thread Thread;
    (thread(shiftKeyStuff));

    // Controller1.ButtonA.pressed([]() {
    //   while (abs(tracker1->getRobotPosition().heading - M_PI) > 0.01)
    //     printf("%f\n", tracker1->getRobotPosition().heading);
    // });

    // ANYTHING AFTER THIS FUNCTION WILL NOT BE EXECUTED
    controllerDisplay({{}});
  }
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //  END I/O INITIALIZATION
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //  START EARLY I/O INITIALIZATION
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~

  //   // subscribeButtonListener(Button::SHOOT, &shootButtonSubscriber);
  //   // subscribeButtonListener(Button::SAFTEY_SWITCH,
  //   //  &safteySwitchSubscriber);
  //   // subscribeButtonListener(Button::CANCEL_SHOOTING,
  //   //                         &cancelShootingButtonSubscriber);
  //   // subscribeButtonListener(Button::EXPANSION,
  //   //  &expansionButtonSubscriber);
  //   // subscribeButtonListener(Button::INTAKE, &intakeButtonSubscriber);
  //   // subscribeButtonListener(Button::UNSTUCK_INTAKE,
  //   //                         &unstuckIntakeButtonSubscriber);
  //   // subscribeButtonListener(Button::PTO_SWITCH, &PTOSwitchSubscriber);
  //   // subscribeButtonListener(Button::FLY_WHEEL_TOGGLE,
  //   // &flyWheelButtonSubscriber);

  //   // subscribeReleasedListener(Button::UNSTUCK_INTAKE,
  //   //                           &unstuckIntakeReleasedSubscriber);
  //   // subscribeReleasedListener(Button::INTAKE,
  //   &intakeReleasedSubscriber);

  //     // subscribeAxisListener(Axis::LEFT_DRIVE, &leftDriveSubscriber);
  //     // subscribeAxisListener(Axis::RIGHT_DRIVE, &rightDriveSubscriber);
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //  END EARLY I/O INITIALIZATION
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
}

void controllerDisplay(OdomTracking tracker1) {
  {
    Brain.Screen.clearScreen();
    // tracker = &tracker1;
    Position robotPos1;
    while (1) {
      // reset
      Controller1.Screen.setCursor(0, 0);

      // shots
      // Controller1.Screen.clearLine();
      // Controller1.Screen.print("shots: ");
      // Controller1.Screen.print(shots);
      // Controller1.Screen.newLine();
      // PTO State
      // Controller1.Screen.clearLine();
      // if (PTOState == PTO::INTAKE)
      //   Controller1.Screen.print("intake");
      // else
      //   Controller1.Screen.print("drive");
      // Controller1.Screen.newLine();

      // // Deez Nuts
      // Controller1.Screen.clearLine();
      // Controller1.Screen.print(/* "deez nuts" */ tracker.deltaPos1.x);
      // // Controller1.Screen.print(/* "deez nuts" */
      // tracker.data.curr.pos.x);

      // temp
      Controller1.Screen.clearLine();
      Controller1.Screen.print("drive: ");
      Controller1.Screen.print((LeftDriveA.temperature(fahrenheit) +
                                LeftDriveB.temperature(fahrenheit) +
                                RightDriveA.temperature(fahrenheit) +
                                RightDriveB.temperature(fahrenheit)) /
                               4);
      Controller1.Screen.print(" F");
      Controller1.Screen.newLine();

      Controller1.Screen.clearLine();
      Controller1.Screen.print("cata: ");
      Controller1.Screen.print(Catapult1.temperature(fahrenheit));
      Controller1.Screen.print(" F");
      Controller1.Screen.newLine();

      // tracking
      robotPos1 = Robot::getPosition();
      Brain.Screen.setCursor(1, 1);
      Brain.Screen.clearLine();
      Brain.Screen.print("(");
      Brain.Screen.print(robotPos1.x);
      Brain.Screen.print(",");
      Brain.Screen.print(robotPos1.y);
      Brain.Screen.print(",");
      Brain.Screen.print(robotPos1.heading);
      Brain.Screen.print(")");
      Brain.Screen.newLine();

      Controller1.Screen.clearLine();
      Controller1.Screen.print("(");
      Controller1.Screen.print(robotPos1.x);
      Controller1.Screen.print(",");
      Controller1.Screen.print(robotPos1.y);
      Controller1.Screen.print(",");
      Controller1.Screen.print(robotPos1.heading);
      Controller1.Screen.print(")");
      Controller1.Screen.newLine();

      wait(50, msec);
    }
  }
}